    # Quote Vote - API Specifications (GraphQL Schema Overview)

    This document provides a high-level overview and examples of the GraphQL schema used by the `voxpop-api` backend. This is not exhaustive but outlines the key types, queries, mutations, and subscriptions.

    ## Custom Scalars

    ```graphql
    scalar Date
    scalar ObjectId # Custom scalar representing MongoDB ObjectIds
    ```

    ## Core Types (Examples)

    ```graphql
    type User {
      id: ObjectId!
      username: String!
      name: String
      email: String! # Assuming email is required based on UserModel
      bio: String # Needs to be added based on PRD (Not seen in UserModel)
      avatarUrl: String # Corresponds to UserModel.avatar (type JSON?) or a computed URL
      createdAt: Date! # Corresponds to UserModel.joined
      # Relationships (resolved by API via resolvers in 'relationship/')
      posts(limit: Int, cursor: String): PostConnection! # Paginated user posts
      following(limit: Int, cursor: String): UserConnection! # Users this user follows
      followers(limit: Int, cursor: String): UserConnection! # Users following this user
      buddies(limit: Int, cursor: String): UserConnection! # Users on the buddy list (Requires 'buddyIds' field)
      votes: [Vote!] # Votes cast by this user
      # comments: [Comment!] # Comments made by this user
      # notifications: [Notification!] # Notifications for this user
      # messageRooms: [MessageRoom!] # Chat rooms this user is part of
      # status: Int # From UserModel
      # plan: String # From UserModel
      # admin: Boolean # From UserModel
    }

    type Post {
      id: ObjectId!
      author: User! # Resolved from 'userId' via relationship resolvers
      group: Group # Resolved from 'groupId' (if Group type is defined)
      title: String!
      text: String!
      createdAt: Date! # Corresponds to 'created'
      updatedAt: Date # Needs logic if not in model (potentially use 'created')
      chatroomUrl: String # Needs logic if not in model (or use postId?)
      messageRoomId: String # Exists in PostModel
      # Contextual Voting/Highlighting related fields
      highlightedSections: [HighlightedSection!] # Likely dynamically generated by resolvers based on VoteModel/QuoteModel/CommentModel data associated with this Post
      # Aggregated counts / status
      upvotes: Int! # From PostModel counter (or aggregated from VoteModel)
      downvotes: Int! # From PostModel counter (or aggregated from VoteModel)
      # votedBy: [User!] # Requires resolving IDs in PostModel.votedBy
      # approvedBy: [User!] # Requires resolving IDs in PostModel.approvedBy
      # rejectedBy: [User!] # Requires resolving IDs in PostModel.rejectedBy
      # bookmarkedBy: [User!] # Requires resolving IDs in PostModel.bookmarkedBy
      reportedCount: Int! # Corresponds to 'reported'
      # Relationships
      comments(limit: Int, cursor: String): CommentConnection! # Paginated comments for this post
      votes(limit: Int, cursor: String): VoteConnection! # Votes associated with this post
    }

    # Represents a conceptual highlighted section for reactions/comments
    type HighlightedSection {
      # This type might not directly map to a DB model but generated by resolvers
      id: String! # A unique identifier for the range (e.g., "postid_start_end")
      post: Post!
      startIndex: Int!
      endIndex: Int!
      textSnippet: String! # Extracted text
      # Aggregated reactions for this specific snippet
      upvoteCount: Int!
      downvoteCount: Int!
      # Comments specifically targeting this highlight
      comments(limit: Int, cursor: String): CommentConnection!
      # Who voted on this specific snippet
      voters(type: VoteType): [User!]
    }

    # Represents an individual vote on a specific text range
    type Vote {
        id: ObjectId! # From VoteModel _id
        post: Post! # Resolved from postId
        voter: User! # Resolved from userId
        type: VoteType! # 'up' or 'down'
        startIndex: Int!
        endIndex: Int!
        createdAt: Date!
    }

    enum VoteType {
        up
        down
    }

    type Comment {
      id: ObjectId! # From CommentModel _id
      post: Post! # Resolved from postId
      author: User! # Resolved from userId
      content: String!
      createdAt: Date!
      # Optional fields if comment is tied to a highlight
      startWordIndex: Int
      endWordIndex: Int
      # parentComment: Comment # Needs parentCommentId field in model for replies
      # reactions: [Reaction!] # If reactions are added to comments
    }

    # Represents a chat message (in post chatroom or DM)
    type Message {
        id: ObjectId! # From MessageModel _id
        messageRoom: MessageRoom! # Resolved from messageRoomId
        sender: User! # Resolved from userId
        text: String!
        createdAt: Date!
        # readBy: [User!] # Resolve based on MessageModel.readBy
    }

    # Represents a chat conversation space (Post chatroom or DM)
    type MessageRoom {
        id: ObjectId! # From MessageRoomModel _id
        participants: [User!]! # Resolved from users array
        post: Post # Optional, resolved from postId if it's a post chatroom
        messageType: String! # e.g., 'post_chat', 'direct_message'
        messages(limit: Int, cursor: String): MessageConnection! # Paginated messages
        createdAt: Date!
    }

    type Notification {
        id: ObjectId!
        recipient: User! # Resolved from userId
        sender: User # Resolved from userIdBy (optional)
        notificationType: String! # e.g., 'new_follower', 'post_reply', 'comment_mention', 'new_dm'
        post: Post # Optional, resolved from postId
        # comment: Comment # Optional, needs commentId field added to NotificationModel
        # message: Message # Optional, needs messageId field added
        label: String
        status: String! # e.g., 'new', 'read'
        createdAt: Date!
    }

    # ... other types like Group, Domain, Activity, Reaction (for messages), etc.

    ## Pagination Types (Example)

    type PageInfo {
      hasNextPage: Boolean!
      endCursor: String
    }

    type UserConnection {
      edges: [UserEdge!]!
      pageInfo: PageInfo!
      totalCount: Int # Optional total count
    }
    type UserEdge {
      cursor: String!
      node: User!
    }

    # (Define similar Connection/Edge types for Post, Comment, Message, Notification, Vote etc.)

    ## Example Queries

    type Query {
      # Feed
      feed(limit: Int = 20, cursor: String): PostConnection! # Chronological feed for logged-in user

      # Posts
      post(id: ObjectId!): Post
      postsByUser(userId: ObjectId!, limit: Int = 20, cursor: String): PostConnection!
      # postsByGroup(groupId: ObjectId!, limit: Int = 20, cursor: String): PostConnection!

      # Users
      user(id: ObjectId, username: String): User
      me: User # Currently logged-in user
      # searchUsers(query: String!, limit: Int = 10): [User!]

      # Comments
      commentsByPost(postId: ObjectId!, limit: Int = 20, cursor: String): CommentConnection!

      # Trending
      trendingPosts(limit: Int = 10): [Post!] # Needs implementation

      # Notifications
      notifications(read: Boolean, limit: Int = 20, cursor: String): NotificationConnection!
      unreadNotificationCount: Int!

      # Direct Messages / Chat
      messageRooms(limit: Int = 20, cursor: String): MessageRoomConnection! # List user's DMs/Chatrooms
      messages(messageRoomId: ObjectId!, limit: Int = 50, cursor: String): MessageConnection!

      # Buddies
      buddyList(limit: Int = 20, cursor: String): UserConnection!

      # ... other queries for Groups, Domains, Votes etc.
    }

    ## Example Mutations

    type Mutation {
      # Auth
      # login(...)
      # register(...)

      # Posts
      createPost(groupId: ObjectId!, title: String!, text: String!): Post # Needs input type
      editPost(postId: ObjectId!, title: String, text: String): Post # Needs input type
      deletePost(postId: ObjectId!): Boolean
      reportPost(postId: ObjectId!, reason: String): Boolean # Reason needs model update or separate ReportModel

      # Comments
      createComment(postId: ObjectId!, content: String!, startWordIndex: Int, endWordIndex: Int): Comment # Needs input type, maybe parentCommentId
      # editComment(...)
      # deleteComment(...)

      # Votes/Reactions (on highlights)
      voteOnHighlight(postId: ObjectId!, startIndex: Int!, endIndex: Int!, type: VoteType!): Post # Returns Post to update snippet reaction counts? Or returns HighlightedSection?

      # Follows / Buddies
      followUser(userId: ObjectId!): User
      unfollowUser(userId: ObjectId!): User
      addBuddy(userId: ObjectId!): User
      removeBuddy(userId: ObjectId!): User

      # Direct Messages
      sendDirectMessage(recipientId: ObjectId!, text: String!): Message # Needs input type
      markMessageRead(messageId: ObjectId!): Message # Or markConversationRead(messageRoomId!)

      # Notifications
      markNotificationRead(notificationId: ObjectId!): Notification
      markAllNotificationsRead: Boolean

      # Profile
      updateProfile(name: String, bio: String, avatarUrl: String): User # Needs input type

      # ... other mutations for Groups, Invites, etc.
    }

    ## Example Subscriptions (Real-time)

    type Subscription {
      newComment(postId: ObjectId!): Comment # New comment added to a specific post's chatroom
      newMessage(messageRoomId: ObjectId!): Message # New message in a specific room (post chat or DM)
      newNotification(userId: ObjectId!): Notification # New notification for the specified user
      # typingIndicator(messageRoomId: ObjectId!): TypingUser # Example: { userId, username }
    }
    ```

3.  **Database Schema Design (MongoDB Conceptual Schema):**

    - **Location:** Create a new file named `memory-bank/database-schema.md`.
    - **Action:** Paste the following content into the new file. This refines the schema based on our analysis of the existing models and incorporates PRD elements like `buddyIds`.

    ````markdown
    # Quote Vote - Database Schema Design (MongoDB / Mongoose)

    This document outlines the conceptual schema design for the MongoDB collections used by the `voxpop-api` backend, based on analysis of the existing Mongoose models and incorporating requirements from the V1 PRD.

    **Note:** Field names reflect potential standardization (e.g., `followingIds` instead of `_followingId`). Existing model files (`resolvers/models/*`) should be updated accordingly during implementation.

    ## Collection: `users` (Corresponds to `UserModel.js`)

    ```javascript
    {
      _id: ObjectId, // Auto-generated MongoDB ID
      username: { type: String, unique: true, lowercase: true, trim: true, required: true, index: true },
      name: String, // Optional display name
      email: { type: String, unique: true, lowercase: true, trim: true, required: true, index: true },
      hash_password: String, // If using local password auth strategy
      authProviderId: String, // Optional: If using external auth (e.g., Google ID) - indexed
      bio: String, // New field needed for PRD
      avatarUrl: String, // Store URL, potentially update from UserModel.avatar JSON
      status: Number, // Meaning needs clarification (e.g., 0=pending, 1=active, 2=banned)
      plan: { type: String, default: 'personal' }, // e.g., 'personal', 'org_admin'
      stripeCustomerId: String, // For potential future payments
      // Follows & Buddies
      followingIds: [ObjectId], // Standardized name for users this user follows - indexed if needed for feed perf.
      followerIds: [ObjectId],  // Standardized name for users following this user - indexed if needed for counts/notifications
      buddyIds: [ObjectId],     // New field needed for PRD Buddy List feature
      // Relationships & References (Consider if needed directly on user or resolved via queries)
      // voteIds: [ObjectId], // Reference to votes cast by user (likely queried, not stored here)
      // commentIds: [ObjectId], // Reference to comments made by user (likely queried)
      // postIds: [ObjectId], // Reference to posts made by user (likely queried)
      // messageRoomIds: [ObjectId], // Reference to rooms user is in (likely queried)
      // Other Fields
      favoritedPostIds: [ObjectId], // Array of Post IDs user favorited (from UserModel.favorited)
      notificationSettings: { // Example embedded settings
        newFollower: { type: Boolean, default: true },
        newDm: { type: Boolean, default: true },
        postReply: { type: Boolean, default: true },
        commentMention: { type: Boolean, default: true }, // Example
      },
      admin: { type: Boolean, default: false }, // Role check
      joined: { type: Date, default: Date.now }, // Corresponds to 'created'
      // Deprecate? These counts can be derived via aggregation unless performance demands caching.
      // upvotes: { type: Number, default: 0 }, // Total upvotes received?
      // downvotes: { type: Number, default: 0 }, // Total downvotes received?
      // tokens: Number, // Meaning needs clarification (from UserModel)
      // _wallet: String, // Meaning needs clarification (from UserModel)
      // companyName: String, // From UserModel - relevant for Org features?
    }
    ```
    ````

    ## Collection: `posts` (Corresponds to `PostModel.js`)

    ```javascript
    {
      _id: ObjectId,
      authorId: { type: ObjectId, required: true, index: true }, // Renamed from 'userId' for clarity
      groupId: { type: ObjectId, index: true }, // Optional: If post belongs to a Group/Domain
      title: { type: String, required: true },
      text: { type: String, required: true }, // Text content of the post
      createdAt: { type: Date, default: Date.now, index: true }, // For sorting feeds
      updatedAt: { type: Date, default: Date.now }, // Should be updated on edit
      // URL / Linking
      url: String, // Optional external URL associated with post?
      urlId: String, // Meaning? (from PostModel) - maybe slug for post URL?
      messageRoomId: { type: ObjectId, index: true }, // Link to the associated MessageRoom for chat
      // Status / Moderation
      reportedCount: { type: Number, default: 0 }, // Renamed from 'reported'
      reportedBy: [ObjectId], // Users who reported this post
      // Vote/Reaction Cache (Consider if needed for performance vs. aggregation)
      // upvotes: { type: Number, default: 0 }, // Total upvotes on the post (potentially derived from VoteModel)
      // downvotes: { type: Number, default: 0 }, // Total downvotes on the post (potentially derived)
      // Derived/Calculated Fields (Potentially populated by background jobs or aggregation)
      // commentCount: { type: Number, default: 0},
      // trendingScore: Number, // Example
      // pointTimestamp: Date, // Meaning? (from PostModel) - timestamp for trending score calculation?
      // dayPoints: Number, // Meaning? (from PostModel) - trending score?
      // Deprecate? These arrays store who took an action, better queried from VoteModel/BookmarkModel
      // approvedBy: [ObjectId],
      // rejectedBy: [ObjectId],
      // votedBy: [ObjectId], // Ambiguous if VoteModel exists
      // bookmarkedBy: [ObjectId], // Consider a dedicated BookmarkModel if needed
    }
    // Text index for searching post content
    // schema.index({ title: 'text', text: 'text' }); // Example text index
    ```

    ## Collection: `comments` (Corresponds to `CommentModel.js`)

    ```javascript
    {
      _id: ObjectId,
      postId: { type: ObjectId, required: true, index: true }, // Link to the Post
      authorId: { type: ObjectId, required: true, index: true }, // Renamed from 'userId'
      content: { type: String, required: true },
      createdAt: { type: Date, default: Date.now, index: true },
      updatedAt: { type: Date, default: Date.now },
      parentCommentId: { type: ObjectId, index: true }, // For threading replies
      // Fields for comments on highlighted text ranges
      startWordIndex: Number, // Optional: index from CommentModel
      endWordIndex: Number, // Optional: index from CommentModel
      // url: String, // Meaning? External link related to comment? (from CommentModel)
      // reactions: [ EmbeddedReactionSubdocument ], // Optional: if comments can be reacted to
    }
    // schema.index({ content: 'text' }); // Text index
    ```

    ## Collection: `votes` (Corresponds to `VoteModel.js`)

    ```javascript
    {
      _id: ObjectId,
      postId: { type: ObjectId, required: true, index: true },
      userId: { type: ObjectId, required: true, index: true }, // User casting the vote
      type: { type: String, enum: ['up', 'down'], required: true }, // Vote direction
      // Context for the vote (specific text range)
      startWordIndex: { type: Number, required: true },
      endWordIndex: { type: Number, required: true },
      createdAt: { type: Date, default: Date.now, index: true },
      // content: String, // Snippet of voted text? Likely redundant if start/end index present (from VoteModel)
      // tags: String, // Meaning? (from VoteModel)
    }
    // Compound index for finding votes by user on a specific post range
    // schema.index({ postId: 1, userId: 1, startWordIndex: 1, endWordIndex: 1 }, { unique: true });
    ```

    ## Collection: `message_rooms` (Corresponds to `MessageRoomModel.js`)

    ```javascript
    {
      _id: ObjectId,
      participants: { type: [ObjectId], required: true, index: true }, // Renamed from 'users'
      postId: { type: ObjectId, index: true }, // Optional: Link if this is a post's chatroom
      messageType: { type: String, enum: ['post_chat', 'direct_message'], required: true, index: true },
      createdAt: { type: Date, default: Date.now },
      // Optional cache fields for performance
      lastMessageId: { type: ObjectId },
      lastMessageAt: { type: Date, index: true }, // For sorting conversations
      lastMessageSnippet: String,
      // unreadCounts: [ { userId: ObjectId, count: Number } ] // Cache unread count per participant?
    }
    ```

    ## Collection: `messages` (Corresponds to `MessageModel.js`)

    ```javascript
    {
      _id: ObjectId,
      messageRoomId: { type: ObjectId, required: true, index: true },
      senderId: { type: ObjectId, required: true, index: true }, // Renamed from 'userId'
      text: { type: String, required: true },
      createdAt: { type: Date, default: Date.now, index: true }, // For sorting messages
      readBy: { type: [ObjectId], default: [], index: true } // Users who have read this message
      // title: String, // Use case unclear (from MessageModel) - Subject?
      // reactions: [ EmbeddedReactionSubdocument ], // Optional message reactions (using ReactionModel?)
    }
    ```

    ## Collection: `notifications` (Corresponds to `NotificationModel.js`)

    ```javascript
    {
      _id: ObjectId,
      recipientId: { type: ObjectId, required: true, index: true }, // Renamed from 'userId'
      senderId: { type: ObjectId, index: true }, // User causing notification (renamed from userIdBy)
      notificationType: {
          type: String,
          required: true,
          enum: ['new_follower', 'post_reply', 'comment_reply', 'post_mention', 'comment_mention', 'new_dm'], // Example types
          index: true
      },
      postId: { type: ObjectId, index: true }, // Optional reference
      commentId: { type: ObjectId, index: true }, // Optional reference (Need to add field)
      messageId: { type: ObjectId, index: true }, // Optional reference (Need to add field)
      messageRoomId: { type: ObjectId, index: true }, // Optional reference (Need to add field)
      label: String, // Short description/text of the notification
      status: { type: String, enum: ['new', 'read'], default: 'new', index: true },
      createdAt: { type: Date, default: Date.now, index: true },
    }
    ```

    ## Other Existing Models (Brief Notes - Purpose/V1 Relevance Needs Clarification)

    - **`ActivityModel`**: Logs user actions. Useful for auditing or generating feeds/analytics.
    - **`CollectionModel`**: Groups content. Might be post-V1 or relate to Org features.
    - **`ContentModel`**: Generic content type? Relation to `PostModel` unclear. May relate to Org features/Domains.
    - **`CreatorModel`**: User profile focused on content creation? Relation to `UserModel` unclear.
    - **`DomainModel`**: Likely for Org/self-hosted instances, managing access by domain.
    - **`GroupModel`**: Similar to Domains, possibly for finer-grained communities within a domain.
    - **`QuoteModel`**: Seems related to highlighting text, but role needs clarification vs. `VoteModel` and `CommentModel`.
    - **`ReactionModel`**: Appears tied to _messages_ (`messageId`) and uses emojis. Separate from `VoteModel` for post highlights.
    - **`VoteLogModel`**: Auditing votes? Potentially redundant if `VoteModel` captures the necessary info.

    **Recommendation:** Focus V1 implementation on refining and using `users`, `posts`, `comments`, `votes`, `message_rooms`, `messages`, `notifications`. Clarify or defer refinement of other models unless essential for a core V1 feature.

    ```

    ```

4.  **Contribution Guide:**

    - **Location:** As mentioned, the standard place is a file named `CONTRIBUTING.md` in the root of your actual project repository (`/c:/Users/EDC/IzecProjects/quotevote-nextjs/`). GitHub and other platforms often look for this specific file name.
    - **Recommendation:** Create the `CONTRIBUTING.md` file in the project root.
    - **Alternative:** If you want to keep the draft purely within your planning area for now, create `memory-bank/contribution-guide-draft.md`.
    - **Action:** Paste the following content into the chosen file (`CONTRIBUTING.md` in the project root is preferred).

    ```markdown
    # Contributing to Quote Vote

    First off, thank you for considering contributing to Quote Vote! We're excited to build a better kind of online conversation space together. Your help is appreciated, whether it's reporting a bug, submitting a fix, proposing a new feature, or improving documentation.

    This document provides guidelines for contributing to the project.

    ## Table of Contents

    - [Code of Conduct](#code-of-conduct)
    - [How Can I Contribute?](#how-can-i-contribute)
      - [Reporting Bugs](#reporting-bugs)
      - [Suggesting Enhancements](#suggesting-enhancements)
      - [Your First Code Contribution](#your-first-code-contribution)
      - [Pull Requests](#pull-requests)
    - [Development Setup](#development-setup)
    - [Styleguides](#styleguides)
      - [Git Commit Messages](#git-commit-messages)
      - [JavaScript/TypeScript Styleguide](#javascripttypescript-styleguide)
      - [GraphQL Styleguide](#graphql-styleguide)
    - [Testing](#testing)
    - [Community](#community)

    ## Code of Conduct

    This project and everyone participating in it are governed by the [Quote Vote Code of Conduct](CODE_OF_CONDUCT.md). By participating, you are expected to uphold this code. Please report unacceptable behavior to [CONTACT METHOD - e.g., project email or core team members]. _(Link CODE_OF_CONDUCT.md if it exists)_

    ## How Can I Contribute?

    ### Reporting Bugs

    If you find a bug, please ensure the bug was not already reported by searching on GitHub under [Issues](https://github.com/quote-vote/quote-vote/issues). _(Update link if repo location changes)_

    If you're unable to find an open issue addressing the problem, [open a new one](https://github.com/quote-vote/quote-vote/issues/new). Be sure to include a **title and clear description**, as much relevant information as possible, and a **code sample or an executable test case** demonstrating the expected behavior that is not occurring. Use the "Bug Report" template if available.

    ### Suggesting Enhancements

    If you have an idea for an enhancement or a new feature, please first check the existing [Issues](https://github.com/quote-vote/quote-vote/issues) and [Pull Requests](https://github.com/quote-vote/quote-vote/pulls) to see if someone else has already proposed it.

    If not, open a new issue, using the "Feature Request" template if available. Provide a clear description of the enhancement, why it would be valuable, and potential implementation ideas if you have them.

    ### Your First Code Contribution

    Unsure where to begin contributing? You can start by looking through `good first issue` and `help wanted` issues:

    - [Good first issues](https://github.com/quote-vote/quote-vote/labels/good%20first%20issue) - issues which should only require a few lines of code, and a test or two.
    - [Help wanted issues](https://github.com/quote-vote/quote-vote/labels/help%20wanted) - issues which should be a bit more involved than `good first issues`.

    Feel free to ask questions on the issue thread if you need clarification.

    ### Pull Requests

    1.  **Fork the repository** and create your branch from `main` (or the appropriate development branch, e.g., `develop`).
    2.  **Set up your development environment** (see [Development Setup](#development-setup)).
    3.  **Make your changes.** Ensure code follows the [Styleguides](#styleguides). Apply necessary model changes or implement new resolvers/types.
    4.  **Add tests** for your changes.
    5.  **Ensure the test suite passes.** (`npm test` or `yarn test`)
    6.  **Ensure your code lints.** (`npm run lint` or `yarn lint`)
    7.  **Commit your changes** using a descriptive commit message (see [Git Commit Messages](#git-commit-messages)).
    8.  **Push your branch** to your fork.
    9.  **Open a Pull Request** to the `main` (or `develop`) branch of the main repository.
    10. **Link the PR to any relevant issues.**
    11. **Provide a clear description** of the problem and solution. Include screenshots or GIFs if relevant for UI changes.
    12. **Respond to review comments** and make changes as necessary.

    ## Development Setup

    _(This section needs specific commands based on your project structure - verify these match your setup)_

    1.  **Prerequisites:** Ensure you have Node.js (specify version, e.g., >= 18.x), Yarn or npm, Docker, and Docker Compose installed.
    2.  **Clone your fork:** `git clone https://github.com/YOUR_USERNAME/quote-vote.git`
    3.  **Navigate to the backend directory:** `cd quote-vote/backend/voxpop-api`
    4.  **Install dependencies:** `yarn install` or `npm install`
    5.  **Set up environment variables:** Copy `.env.example` to `.env` (if it exists) and fill in the necessary values (Database connection strings - `MONGO_URI`, Auth keys, etc.). Refer to `.env.example` or configuration files for required variables.
    6.  **Start supporting services (e.g., MongoDB via Docker if not using Atlas locally):** `docker-compose up -d` (if a `docker-compose.yml` is configured for local DB). Otherwise, ensure connection to MongoDB Atlas is available.
    7.  **Run the development server:** `yarn dev` or `npm run dev` (Check `package.json` scripts)
    8.  Access the GraphQL API endpoint (likely `http://localhost:PORT/graphql` - check `server.js` or config for port).

    _(Add separate setup instructions for the frontend if applicable)_

    ## Styleguides

    ### Git Commit Messages

    - Use the present tense ("Add feature" not "Added feature").
    - Use the imperative mood ("Move cursor to..." not "Moves cursor to...").
    - Limit the first line to 72 characters or less.
    - Reference issues and pull requests liberally after the first line.
    - Consider using [Conventional Commits](https://www.conventionalcommits.org/) for consistency (e.g., `feat:`, `fix:`, `chore:`, `docs:`).

    ### JavaScript/TypeScript Styleguide

    - Follow the configuration set up in ESLint (`.eslintrc.js` or similar) and Prettier (`.prettierrc.js` or similar). Check project root and backend directory.
    - Run `yarn lint --fix` or `npm run lint --fix` to automatically format code.
    - Prefer modern JavaScript (ES6+) as enabled by Babel. Use TypeScript if adopted.

    ### GraphQL Styleguide

    - Follow standard GraphQL naming conventions (CamelCase for types and fields, ALL_CAPS for Enums).
    - Ensure schema types (`app/data/types/`) and definitions (`app/data/type_definition/`) are clear.
    - Document types and fields using GraphQL descriptions (`""" Description """`) where appropriate.

    ## Testing

    _(Specify testing frameworks used in the project - check `package.json` and `tests/` directories, e.g., Jest, Mocha, Chai)_

    - Add unit tests for new utility functions and complex resolver logic.
    - Add integration tests for GraphQL queries and mutations.
    - Run tests using `yarn test` or `npm test` (check `package.json`).
    - Aim for reasonable test coverage for new contributions.

    ## Community

    _(Add links to Discord, Slack, Mailing list, etc. if applicable)_

    - Join our community Discord: [Link to Discord Server - Placeholder]
    - Discuss development in the `#development` channel.

    Thank you again for your contribution!
    ```
